-- SATURDAY 30 APRIL --

Instead of pattern matching on the whole rule I will try to pattern match varibale by variable
For each definition X create a Match function which determines if X and Y are equal

PROBLEM:
the Match rule works either only for constructors of only for numbers. If in the future actual numbers will be used then I will need to change something about this Match rule
(Main) = (Match 1 1) -> 0
(Main) = (Match True True) -> 1

BIG PROBLEM with scoping of variables: 
(Map_2 a b) = (If (Case b (Nil)) (b) (Case b (Cons c d)) ((Cons_0) ((a) (c)) ((Map_0) (a) (d))))
Cannot do ```Case b (Cons c d)``` because c and d are not in scope

Possible solution:
Do like a synthesis: make a new rule for each case for each parameter

-- FRIDAY 29 APRIL --

TODO: 
 - let contructor (desugar to a lambda)
 - pattern patching (use helper rule)

 PROBLEMS:
 - friend function has no catchall rule
 - the order of the variables is messed up 
 - rn it's not possible to mix Constructors and variables, the constructors will go first always

-- THURSDAY 28 APRIL --

The solution of always using rules with 0 arguments will not work when implementing pattern matching.
Another solution to solve:
 - implementing pattern matching easily
 - currying function
 - supporting eta reduced functions
is a blend of the two previous solutions:
    1) create all curried-functions with less parameters
    2) always use App with 0 arguments first
    3) pattern matching happens only in the rule with the most arguments
Example:
    (Id2_0) = (@a (@b (@c (Id2_3 a b c))))
    (Id2_1 a) = (@b (@c (Id2_3 a b c)))
    (Id2_2 a b) = (@c (Id2_3 a b c))
    (Id2_3 True b c) = (b)
    (Id2_3 False b c) = (c) 

    (Main) = ((Id2_0) True 1 0)
    ->
    1
TODO:
Check if intermidiate sub-functions
    (Id2_1 a) = (@b (@c (Id2_3 a b c)))
    (Id2_2 a b) = (@c (Id2_3 a b c))
are actually needed or not, probably not since App is called always with _0

ETA-reduced functions don't have pattern matching so there's no need to create functions with more parameters




Agda is case sensitive, so naming collisions may arise if simply uppercase the first letter of a definition
possible solution: add underscore and a number after the uppercased defintion because agda does not allow it but HVM does


-- TUESDAY 26 APRIL -- 

HVM does not support currying of Rules
(Matteo a b) = 42

(Main) = ((Matteo 1) 2)
->
((Matteo 1) 2)

a possible solution is creating a number of rules equal to to number of arguments each with different number of arguments
(Matteo2 a b) = 42
(Matteo1 a) = @b (42)
(Matteo0) = @a @b (42)

(Main) = ((Matteo1 1) 2)
->
42

Problem:
(Matteo2 param1 param0) = (param1 param0)
(Matteo1 param1) = @param0 (param1 param0)
(Matteo0) = @param1 @param0 (param1 param0)

(Luca0) = (Matteo1 (@param0 (param0)))
(Luca1 param1) = (Matteo2 (@param0 (param0)) param1) -- Had to add Luca1 from Luca0, so sometimes the index has to increase too.. very complex because Luca0 is eta reduced in agda

(Nikos) = (Luca1 True)

(Main) = Nikos

final solution: always use rules with 0 arguments and call always App with 0 arguments first on that rule
(Matteo) = @x @y (x y)

(Luca) = ((Matteo) (@x (x)))

(Main) = ((Luca) True)

Remarks: This will probably affect performance negatively, but it's the simplest implementation. In the future it may be worth changing this to use rules with many arguments.